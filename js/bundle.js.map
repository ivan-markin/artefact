{"version":3,"sources":["node_modules/browser-pack/_prelude.js","node_modules/@glidejs/glide/dist/glide.js","src/js/main.js"],"names":["r","e","n","t","o","i","f","c","require","u","a","Error","code","p","exports","call","length","1","module","global","factory","this","defaults","type","startAt","perView","focusAt","gap","autoplay","hoverpause","keyboard","bound","swipeThreshold","dragThreshold","perTouch","touchRatio","touchAngle","animationDuration","rewind","rewindDuration","animationTimingFunc","throttle","direction","peek","breakpoints","classes","ltr","rtl","slider","carousel","swipeable","dragging","cloneSlide","activeNav","activeSlide","disabledArrow","warn","msg","console","error","_typeof","Symbol","iterator","obj","constructor","prototype","classCallCheck","instance","Constructor","TypeError","createClass","protoProps","staticProps","defineProperties","target","props","descriptor","enumerable","configurable","writable","Object","defineProperty","key","get","object","property","receiver","Function","desc","getOwnPropertyDescriptor","undefined","value","getter","parent","getPrototypeOf","_extends","assign","arguments","source","hasOwnProperty","possibleConstructorReturn","self","ReferenceError","toInt","parseInt","isString","isObject","isFunction","isUndefined","isArray","Array","define","prop","definition","mergeOptions","settings","options","EventsBus","event","handler","on","hop","events","index","push","remove","context","emit","forEach","item","Glide","extensions","_e","_c","glide","name","_name","components","mount","transformers","_t","pattern","Run","make","distance","Transition","disable","Move","interval","disabled","_o","set","_i","_d","status","selector","now","Date","getTime","func","wait","timeout","args","result","previous","later","leading","apply","throttled","at","remaining","clearTimeout","trailing","setTimeout","cancel","MARGIN_TYPE","siblings","node","parentNode","firstChild","matched","nextSibling","nodeType","exist","window","HTMLElement","TRACK_SELECTOR","EventsBinder","el","closure","capture","listeners","addEventListener","removeEventListener","VALID_DIRECTIONS","FLIPED_MOVEMENTS",">","<","=","Rtl","Components","modify","translate","Direction","is","mutator","Events","TRANSFORMERS","Gaps","Clones","grow","Peek","before","width","Sizes","slideWidth","concat","mutate","transformer","supportsPassive","opts","supportsPassive$1","START_EVENTS","MOVE_EVENTS","END_EVENTS","MOUSE_EVENTS","sortBreakpoints","points","keys","sort","reduce","k","COMPONENTS","Html","root","track","querySelector","slides","slice","wrapper","children","filter","slide","classList","contains","_r","document","Translate","transform","style","isType","isOffset","after","movement","compose","duration","transition","callback","enable","offset","resolve","token","split","join","addClass","add","removeClass","_v","indexOf","setupSlides","setupWrapper","dimention","wrapperSize","offsetWidth","reductor","len","marginLeft","marginRight","_this","items","collect","_Glide$settings","part","start","end","Math","max","floor","clone","cloneNode","_clone","unshift","append","_Components$Html","half","prepend","reverse","appendChild","_i2","insertBefore","_i3","removeChild","Resize","Binder","bind","unbind","off","destroy","Build","typeClass","activeClass","sibling","removeClasses","move","calculate","isStart","isEnd","steps","countableSteps","min","_m","step","substr","Swipe","swipeSin","swipeStartX","swipeStartY","passive","bindSwipeStart","swipe","touches","pageX","pageY","bindSwipeMove","bindSwipeEnd","subExSx","subEySy","powEX","abs","powEY","swipeHypotenuse","sqrt","swipeCathetus","asin","PI","stopPropagation","parseFloat","threshold","swipeDistance","swipeDeg","round","unbindSwipeMove","unbindSwipeEnd","unbindSwipeStart","_this2","_this3","changedTouches","Images","dragstart","preventDefault","Anchors","detached","prevented","_a","querySelectorAll","click","detach","draggable","setAttribute","getAttribute","removeAttribute","attach","Controls","_n","addBindings","setActive","removeActive","controls","removeBindings","elements","currentTarget","Keyboard","press","keyCode","Autoplay","setInterval","stop","time","clearInterval","Breakpoints","match","matchMedia","point","matches","Glide$$1","__proto__","subClass","superClass","create","setPrototypeOf","inherits","amd","setBreakpoints"],"mappings":"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","file":"bundle.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","/*!\n * Glide.js v3.4.1\n * (c) 2013-2019 Jędrzej Chałubek <jedrzej.chalubek@gmail.com> (http://jedrzejchalubek.com/)\n * Released under the MIT License.\n */\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.Glide = factory());\n}(this, (function () { 'use strict';\n\n  var defaults = {\n    /**\n     * Type of the movement.\n     *\n     * Available types:\n     * `slider` - Rewinds slider to the start/end when it reaches the first or last slide.\n     * `carousel` - Changes slides without starting over when it reaches the first or last slide.\n     *\n     * @type {String}\n     */\n    type: 'slider',\n\n    /**\n     * Start at specific slide number defined with zero-based index.\n     *\n     * @type {Number}\n     */\n    startAt: 0,\n\n    /**\n     * A number of slides visible on the single viewport.\n     *\n     * @type {Number}\n     */\n    perView: 1,\n\n    /**\n     * Focus currently active slide at a specified position in the track.\n     *\n     * Available inputs:\n     * `center` - Current slide will be always focused at the center of a track.\n     * `0,1,2,3...` - Current slide will be focused on the specified zero-based index.\n     *\n     * @type {String|Number}\n     */\n    focusAt: 0,\n\n    /**\n     * A size of the gap added between slides.\n     *\n     * @type {Number}\n     */\n    gap: 10,\n\n    /**\n     * Change slides after a specified interval. Use `false` for turning off autoplay.\n     *\n     * @type {Number|Boolean}\n     */\n    autoplay: false,\n\n    /**\n     * Stop autoplay on mouseover event.\n     *\n     * @type {Boolean}\n     */\n    hoverpause: true,\n\n    /**\n     * Allow for changing slides with left and right keyboard arrows.\n     *\n     * @type {Boolean}\n     */\n    keyboard: true,\n\n    /**\n     * Stop running `perView` number of slides from the end. Use this\n     * option if you don't want to have an empty space after\n     * a slider. Works only with `slider` type and a\n     * non-centered `focusAt` setting.\n     *\n     * @type {Boolean}\n     */\n    bound: false,\n\n    /**\n     * Minimal swipe distance needed to change the slide. Use `false` for turning off a swiping.\n     *\n     * @type {Number|Boolean}\n     */\n    swipeThreshold: 80,\n\n    /**\n     * Minimal mouse drag distance needed to change the slide. Use `false` for turning off a dragging.\n     *\n     * @type {Number|Boolean}\n     */\n    dragThreshold: 120,\n\n    /**\n     * A maximum number of slides to which movement will be made on swiping or dragging. Use `false` for unlimited.\n     *\n     * @type {Number|Boolean}\n     */\n    perTouch: false,\n\n    /**\n     * Moving distance ratio of the slides on a swiping and dragging.\n     *\n     * @type {Number}\n     */\n    touchRatio: 0.5,\n\n    /**\n     * Angle required to activate slides moving on swiping or dragging.\n     *\n     * @type {Number}\n     */\n    touchAngle: 45,\n\n    /**\n     * Duration of the animation in milliseconds.\n     *\n     * @type {Number}\n     */\n    animationDuration: 400,\n\n    /**\n     * Allows looping the `slider` type. Slider will rewind to the first/last slide when it's at the start/end.\n     *\n     * @type {Boolean}\n     */\n    rewind: true,\n\n    /**\n     * Duration of the rewinding animation of the `slider` type in milliseconds.\n     *\n     * @type {Number}\n     */\n    rewindDuration: 800,\n\n    /**\n     * Easing function for the animation.\n     *\n     * @type {String}\n     */\n    animationTimingFunc: 'cubic-bezier(.165, .840, .440, 1)',\n\n    /**\n     * Throttle costly events at most once per every wait milliseconds.\n     *\n     * @type {Number}\n     */\n    throttle: 10,\n\n    /**\n     * Moving direction mode.\n     *\n     * Available inputs:\n     * - 'ltr' - left to right movement,\n     * - 'rtl' - right to left movement.\n     *\n     * @type {String}\n     */\n    direction: 'ltr',\n\n    /**\n     * The distance value of the next and previous viewports which\n     * have to peek in the current view. Accepts number and\n     * pixels as a string. Left and right peeking can be\n     * set up separately with a directions object.\n     *\n     * For example:\n     * `100` - Peek 100px on the both sides.\n     * { before: 100, after: 50 }` - Peek 100px on the left side and 50px on the right side.\n     *\n     * @type {Number|String|Object}\n     */\n    peek: 0,\n\n    /**\n     * Collection of options applied at specified media breakpoints.\n     * For example: display two slides per view under 800px.\n     * `{\n     *   '800px': {\n     *     perView: 2\n     *   }\n     * }`\n     */\n    breakpoints: {},\n\n    /**\n     * Collection of internally used HTML classes.\n     *\n     * @todo Refactor `slider` and `carousel` properties to single `type: { slider: '', carousel: '' }` object\n     * @type {Object}\n     */\n    classes: {\n      direction: {\n        ltr: 'glide--ltr',\n        rtl: 'glide--rtl'\n      },\n      slider: 'glide--slider',\n      carousel: 'glide--carousel',\n      swipeable: 'glide--swipeable',\n      dragging: 'glide--dragging',\n      cloneSlide: 'glide__slide--clone',\n      activeNav: 'glide__bullet--active',\n      activeSlide: 'glide__slide--active',\n      disabledArrow: 'glide__arrow--disabled'\n    }\n  };\n\n  /**\n   * Outputs warning message to the bowser console.\n   *\n   * @param  {String} msg\n   * @return {Void}\n   */\n  function warn(msg) {\n    console.error(\"[Glide warn]: \" + msg);\n  }\n\n  var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  };\n\n  var classCallCheck = function (instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  };\n\n  var createClass = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n\n  var _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  var get = function get(object, property, receiver) {\n    if (object === null) object = Function.prototype;\n    var desc = Object.getOwnPropertyDescriptor(object, property);\n\n    if (desc === undefined) {\n      var parent = Object.getPrototypeOf(object);\n\n      if (parent === null) {\n        return undefined;\n      } else {\n        return get(parent, property, receiver);\n      }\n    } else if (\"value\" in desc) {\n      return desc.value;\n    } else {\n      var getter = desc.get;\n\n      if (getter === undefined) {\n        return undefined;\n      }\n\n      return getter.call(receiver);\n    }\n  };\n\n  var inherits = function (subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n  };\n\n  var possibleConstructorReturn = function (self, call) {\n    if (!self) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n  };\n\n  /**\n   * Converts value entered as number\n   * or string to integer value.\n   *\n   * @param {String} value\n   * @returns {Number}\n   */\n  function toInt(value) {\n    return parseInt(value);\n  }\n\n  /**\n   * Converts value entered as number\n   * or string to flat value.\n   *\n   * @param {String} value\n   * @returns {Number}\n   */\n  function toFloat(value) {\n    return parseFloat(value);\n  }\n\n  /**\n   * Indicates whether the specified value is a string.\n   *\n   * @param  {*}   value\n   * @return {Boolean}\n   */\n  function isString(value) {\n    return typeof value === 'string';\n  }\n\n  /**\n   * Indicates whether the specified value is an object.\n   *\n   * @param  {*} value\n   * @return {Boolean}\n   *\n   * @see https://github.com/jashkenas/underscore\n   */\n  function isObject(value) {\n    var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);\n\n    return type === 'function' || type === 'object' && !!value; // eslint-disable-line no-mixed-operators\n  }\n\n  /**\n   * Indicates whether the specified value is a number.\n   *\n   * @param  {*} value\n   * @return {Boolean}\n   */\n  function isNumber(value) {\n    return typeof value === 'number';\n  }\n\n  /**\n   * Indicates whether the specified value is a function.\n   *\n   * @param  {*} value\n   * @return {Boolean}\n   */\n  function isFunction(value) {\n    return typeof value === 'function';\n  }\n\n  /**\n   * Indicates whether the specified value is undefined.\n   *\n   * @param  {*} value\n   * @return {Boolean}\n   */\n  function isUndefined(value) {\n    return typeof value === 'undefined';\n  }\n\n  /**\n   * Indicates whether the specified value is an array.\n   *\n   * @param  {*} value\n   * @return {Boolean}\n   */\n  function isArray(value) {\n    return value.constructor === Array;\n  }\n\n  /**\n   * Creates and initializes specified collection of extensions.\n   * Each extension receives access to instance of glide and rest of components.\n   *\n   * @param {Object} glide\n   * @param {Object} extensions\n   *\n   * @returns {Object}\n   */\n  function mount(glide, extensions, events) {\n    var components = {};\n\n    for (var name in extensions) {\n      if (isFunction(extensions[name])) {\n        components[name] = extensions[name](glide, components, events);\n      } else {\n        warn('Extension must be a function');\n      }\n    }\n\n    for (var _name in components) {\n      if (isFunction(components[_name].mount)) {\n        components[_name].mount();\n      }\n    }\n\n    return components;\n  }\n\n  /**\n   * Defines getter and setter property on the specified object.\n   *\n   * @param  {Object} obj         Object where property has to be defined.\n   * @param  {String} prop        Name of the defined property.\n   * @param  {Object} definition  Get and set definitions for the property.\n   * @return {Void}\n   */\n  function define(obj, prop, definition) {\n    Object.defineProperty(obj, prop, definition);\n  }\n\n  /**\n   * Sorts aphabetically object keys.\n   *\n   * @param  {Object} obj\n   * @return {Object}\n   */\n  function sortKeys(obj) {\n    return Object.keys(obj).sort().reduce(function (r, k) {\n      r[k] = obj[k];\n\n      return r[k], r;\n    }, {});\n  }\n\n  /**\n   * Merges passed settings object with default options.\n   *\n   * @param  {Object} defaults\n   * @param  {Object} settings\n   * @return {Object}\n   */\n  function mergeOptions(defaults, settings) {\n    var options = _extends({}, defaults, settings);\n\n    // `Object.assign` do not deeply merge objects, so we\n    // have to do it manually for every nested object\n    // in options. Although it does not look smart,\n    // it's smaller and faster than some fancy\n    // merging deep-merge algorithm script.\n    if (settings.hasOwnProperty('classes')) {\n      options.classes = _extends({}, defaults.classes, settings.classes);\n\n      if (settings.classes.hasOwnProperty('direction')) {\n        options.classes.direction = _extends({}, defaults.classes.direction, settings.classes.direction);\n      }\n    }\n\n    if (settings.hasOwnProperty('breakpoints')) {\n      options.breakpoints = _extends({}, defaults.breakpoints, settings.breakpoints);\n    }\n\n    return options;\n  }\n\n  var EventsBus = function () {\n    /**\n     * Construct a EventBus instance.\n     *\n     * @param {Object} events\n     */\n    function EventsBus() {\n      var events = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      classCallCheck(this, EventsBus);\n\n      this.events = events;\n      this.hop = events.hasOwnProperty;\n    }\n\n    /**\n     * Adds listener to the specifed event.\n     *\n     * @param {String|Array} event\n     * @param {Function} handler\n     */\n\n\n    createClass(EventsBus, [{\n      key: 'on',\n      value: function on(event, handler) {\n        if (isArray(event)) {\n          for (var i = 0; i < event.length; i++) {\n            this.on(event[i], handler);\n          }\n        }\n\n        // Create the event's object if not yet created\n        if (!this.hop.call(this.events, event)) {\n          this.events[event] = [];\n        }\n\n        // Add the handler to queue\n        var index = this.events[event].push(handler) - 1;\n\n        // Provide handle back for removal of event\n        return {\n          remove: function remove() {\n            delete this.events[event][index];\n          }\n        };\n      }\n\n      /**\n       * Runs registered handlers for specified event.\n       *\n       * @param {String|Array} event\n       * @param {Object=} context\n       */\n\n    }, {\n      key: 'emit',\n      value: function emit(event, context) {\n        if (isArray(event)) {\n          for (var i = 0; i < event.length; i++) {\n            this.emit(event[i], context);\n          }\n        }\n\n        // If the event doesn't exist, or there's no handlers in queue, just leave\n        if (!this.hop.call(this.events, event)) {\n          return;\n        }\n\n        // Cycle through events queue, fire!\n        this.events[event].forEach(function (item) {\n          item(context || {});\n        });\n      }\n    }]);\n    return EventsBus;\n  }();\n\n  var Glide = function () {\n    /**\r\n     * Construct glide.\r\n     *\r\n     * @param  {String} selector\r\n     * @param  {Object} options\r\n     */\n    function Glide(selector) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      classCallCheck(this, Glide);\n\n      this._c = {};\n      this._t = [];\n      this._e = new EventsBus();\n\n      this.disabled = false;\n      this.selector = selector;\n      this.settings = mergeOptions(defaults, options);\n      this.index = this.settings.startAt;\n    }\n\n    /**\r\n     * Initializes glide.\r\n     *\r\n     * @param {Object} extensions Collection of extensions to initialize.\r\n     * @return {Glide}\r\n     */\n\n\n    createClass(Glide, [{\n      key: 'mount',\n      value: function mount$$1() {\n        var extensions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        this._e.emit('mount.before');\n\n        if (isObject(extensions)) {\n          this._c = mount(this, extensions, this._e);\n        } else {\n          warn('You need to provide a object on `mount()`');\n        }\n\n        this._e.emit('mount.after');\n\n        return this;\n      }\n\n      /**\r\n       * Collects an instance `translate` transformers.\r\n       *\r\n       * @param  {Array} transformers Collection of transformers.\r\n       * @return {Void}\r\n       */\n\n    }, {\n      key: 'mutate',\n      value: function mutate() {\n        var transformers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n        if (isArray(transformers)) {\n          this._t = transformers;\n        } else {\n          warn('You need to provide a array on `mutate()`');\n        }\n\n        return this;\n      }\n\n      /**\r\n       * Updates glide with specified settings.\r\n       *\r\n       * @param {Object} settings\r\n       * @return {Glide}\r\n       */\n\n    }, {\n      key: 'update',\n      value: function update() {\n        var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        this.settings = mergeOptions(this.settings, settings);\n\n        if (settings.hasOwnProperty('startAt')) {\n          this.index = settings.startAt;\n        }\n\n        this._e.emit('update');\n\n        return this;\n      }\n\n      /**\r\n       * Change slide with specified pattern. A pattern must be in the special format:\r\n       * `>` - Move one forward\r\n       * `<` - Move one backward\r\n       * `={i}` - Go to {i} zero-based slide (eq. '=1', will go to second slide)\r\n       * `>>` - Rewinds to end (last slide)\r\n       * `<<` - Rewinds to start (first slide)\r\n       *\r\n       * @param {String} pattern\r\n       * @return {Glide}\r\n       */\n\n    }, {\n      key: 'go',\n      value: function go(pattern) {\n        this._c.Run.make(pattern);\n\n        return this;\n      }\n\n      /**\r\n       * Move track by specified distance.\r\n       *\r\n       * @param {String} distance\r\n       * @return {Glide}\r\n       */\n\n    }, {\n      key: 'move',\n      value: function move(distance) {\n        this._c.Transition.disable();\n        this._c.Move.make(distance);\n\n        return this;\n      }\n\n      /**\r\n       * Destroy instance and revert all changes done by this._c.\r\n       *\r\n       * @return {Glide}\r\n       */\n\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        this._e.emit('destroy');\n\n        return this;\n      }\n\n      /**\r\n       * Start instance autoplaying.\r\n       *\r\n       * @param {Boolean|Number} interval Run autoplaying with passed interval regardless of `autoplay` settings\r\n       * @return {Glide}\r\n       */\n\n    }, {\n      key: 'play',\n      value: function play() {\n        var interval = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n        if (interval) {\n          this.settings.autoplay = interval;\n        }\n\n        this._e.emit('play');\n\n        return this;\n      }\n\n      /**\r\n       * Stop instance autoplaying.\r\n       *\r\n       * @return {Glide}\r\n       */\n\n    }, {\n      key: 'pause',\n      value: function pause() {\n        this._e.emit('pause');\n\n        return this;\n      }\n\n      /**\r\n       * Sets glide into a idle status.\r\n       *\r\n       * @return {Glide}\r\n       */\n\n    }, {\n      key: 'disable',\n      value: function disable() {\n        this.disabled = true;\n\n        return this;\n      }\n\n      /**\r\n       * Sets glide into a active status.\r\n       *\r\n       * @return {Glide}\r\n       */\n\n    }, {\n      key: 'enable',\n      value: function enable() {\n        this.disabled = false;\n\n        return this;\n      }\n\n      /**\r\n       * Adds cuutom event listener with handler.\r\n       *\r\n       * @param  {String|Array} event\r\n       * @param  {Function} handler\r\n       * @return {Glide}\r\n       */\n\n    }, {\n      key: 'on',\n      value: function on(event, handler) {\n        this._e.on(event, handler);\n\n        return this;\n      }\n\n      /**\r\n       * Checks if glide is a precised type.\r\n       *\r\n       * @param  {String} name\r\n       * @return {Boolean}\r\n       */\n\n    }, {\n      key: 'isType',\n      value: function isType(name) {\n        return this.settings.type === name;\n      }\n\n      /**\r\n       * Gets value of the core options.\r\n       *\r\n       * @return {Object}\r\n       */\n\n    }, {\n      key: 'settings',\n      get: function get$$1() {\n        return this._o;\n      }\n\n      /**\r\n       * Sets value of the core options.\r\n       *\r\n       * @param  {Object} o\r\n       * @return {Void}\r\n       */\n      ,\n      set: function set$$1(o) {\n        if (isObject(o)) {\n          this._o = o;\n        } else {\n          warn('Options must be an `object` instance.');\n        }\n      }\n\n      /**\r\n       * Gets current index of the slider.\r\n       *\r\n       * @return {Object}\r\n       */\n\n    }, {\n      key: 'index',\n      get: function get$$1() {\n        return this._i;\n      }\n\n      /**\r\n       * Sets current index a slider.\r\n       *\r\n       * @return {Object}\r\n       */\n      ,\n      set: function set$$1(i) {\n        this._i = toInt(i);\n      }\n\n      /**\r\n       * Gets type name of the slider.\r\n       *\r\n       * @return {String}\r\n       */\n\n    }, {\n      key: 'type',\n      get: function get$$1() {\n        return this.settings.type;\n      }\n\n      /**\r\n       * Gets value of the idle status.\r\n       *\r\n       * @return {Boolean}\r\n       */\n\n    }, {\n      key: 'disabled',\n      get: function get$$1() {\n        return this._d;\n      }\n\n      /**\r\n       * Sets value of the idle status.\r\n       *\r\n       * @return {Boolean}\r\n       */\n      ,\n      set: function set$$1(status) {\n        this._d = !!status;\n      }\n    }]);\n    return Glide;\n  }();\n\n  function Run (Glide, Components, Events) {\n    var Run = {\n      /**\n       * Initializes autorunning of the glide.\n       *\n       * @return {Void}\n       */\n      mount: function mount() {\n        this._o = false;\n      },\n\n\n      /**\n       * Makes glides running based on the passed moving schema.\n       *\n       * @param {String} move\n       */\n      make: function make(move) {\n        var _this = this;\n\n        if (!Glide.disabled) {\n          Glide.disable();\n\n          this.move = move;\n\n          Events.emit('run.before', this.move);\n\n          this.calculate();\n\n          Events.emit('run', this.move);\n\n          Components.Transition.after(function () {\n            if (_this.isStart()) {\n              Events.emit('run.start', _this.move);\n            }\n\n            if (_this.isEnd()) {\n              Events.emit('run.end', _this.move);\n            }\n\n            if (_this.isOffset('<') || _this.isOffset('>')) {\n              _this._o = false;\n\n              Events.emit('run.offset', _this.move);\n            }\n\n            Events.emit('run.after', _this.move);\n\n            Glide.enable();\n          });\n        }\n      },\n\n\n      /**\n       * Calculates current index based on defined move.\n       *\n       * @return {Void}\n       */\n      calculate: function calculate() {\n        var move = this.move,\n            length = this.length;\n        var steps = move.steps,\n            direction = move.direction;\n\n\n        var countableSteps = isNumber(toInt(steps)) && toInt(steps) !== 0;\n\n        switch (direction) {\n          case '>':\n            if (steps === '>') {\n              Glide.index = length;\n            } else if (this.isEnd()) {\n              if (!(Glide.isType('slider') && !Glide.settings.rewind)) {\n                this._o = true;\n\n                Glide.index = 0;\n              }\n            } else if (countableSteps) {\n              Glide.index += Math.min(length - Glide.index, -toInt(steps));\n            } else {\n              Glide.index++;\n            }\n            break;\n\n          case '<':\n            if (steps === '<') {\n              Glide.index = 0;\n            } else if (this.isStart()) {\n              if (!(Glide.isType('slider') && !Glide.settings.rewind)) {\n                this._o = true;\n\n                Glide.index = length;\n              }\n            } else if (countableSteps) {\n              Glide.index -= Math.min(Glide.index, toInt(steps));\n            } else {\n              Glide.index--;\n            }\n            break;\n\n          case '=':\n            Glide.index = steps;\n            break;\n\n          default:\n            warn('Invalid direction pattern [' + direction + steps + '] has been used');\n            break;\n        }\n      },\n\n\n      /**\n       * Checks if we are on the first slide.\n       *\n       * @return {Boolean}\n       */\n      isStart: function isStart() {\n        return Glide.index === 0;\n      },\n\n\n      /**\n       * Checks if we are on the last slide.\n       *\n       * @return {Boolean}\n       */\n      isEnd: function isEnd() {\n        return Glide.index === this.length;\n      },\n\n\n      /**\n       * Checks if we are making a offset run.\n       *\n       * @param {String} direction\n       * @return {Boolean}\n       */\n      isOffset: function isOffset(direction) {\n        return this._o && this.move.direction === direction;\n      }\n    };\n\n    define(Run, 'move', {\n      /**\n       * Gets value of the move schema.\n       *\n       * @returns {Object}\n       */\n      get: function get() {\n        return this._m;\n      },\n\n\n      /**\n       * Sets value of the move schema.\n       *\n       * @returns {Object}\n       */\n      set: function set(value) {\n        var step = value.substr(1);\n\n        this._m = {\n          direction: value.substr(0, 1),\n          steps: step ? toInt(step) ? toInt(step) : step : 0\n        };\n      }\n    });\n\n    define(Run, 'length', {\n      /**\n       * Gets value of the running distance based\n       * on zero-indexing number of slides.\n       *\n       * @return {Number}\n       */\n      get: function get() {\n        var settings = Glide.settings;\n        var length = Components.Html.slides.length;\n\n        // If the `bound` option is acitve, a maximum running distance should be\n        // reduced by `perView` and `focusAt` settings. Running distance\n        // should end before creating an empty space after instance.\n\n        if (Glide.isType('slider') && settings.focusAt !== 'center' && settings.bound) {\n          return length - 1 - (toInt(settings.perView) - 1) + toInt(settings.focusAt);\n        }\n\n        return length - 1;\n      }\n    });\n\n    define(Run, 'offset', {\n      /**\n       * Gets status of the offsetting flag.\n       *\n       * @return {Boolean}\n       */\n      get: function get() {\n        return this._o;\n      }\n    });\n\n    return Run;\n  }\n\n  /**\n   * Returns a current time.\n   *\n   * @return {Number}\n   */\n  function now() {\n    return new Date().getTime();\n  }\n\n  /**\n   * Returns a function, that, when invoked, will only be triggered\n   * at most once during a given window of time.\n   *\n   * @param {Function} func\n   * @param {Number} wait\n   * @param {Object=} options\n   * @return {Function}\n   *\n   * @see https://github.com/jashkenas/underscore\n   */\n  function throttle(func, wait, options) {\n    var timeout = void 0,\n        context = void 0,\n        args = void 0,\n        result = void 0;\n    var previous = 0;\n    if (!options) options = {};\n\n    var later = function later() {\n      previous = options.leading === false ? 0 : now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n\n    var throttled = function throttled() {\n      var at = now();\n      if (!previous && options.leading === false) previous = at;\n      var remaining = wait - (at - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = at;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n\n    throttled.cancel = function () {\n      clearTimeout(timeout);\n      previous = 0;\n      timeout = context = args = null;\n    };\n\n    return throttled;\n  }\n\n  var MARGIN_TYPE = {\n    ltr: ['marginLeft', 'marginRight'],\n    rtl: ['marginRight', 'marginLeft']\n  };\n\n  function Gaps (Glide, Components, Events) {\n    var Gaps = {\n      /**\n       * Applies gaps between slides. First and last\n       * slides do not receive it's edge margins.\n       *\n       * @param {HTMLCollection} slides\n       * @return {Void}\n       */\n      apply: function apply(slides) {\n        for (var i = 0, len = slides.length; i < len; i++) {\n          var style = slides[i].style;\n          var direction = Components.Direction.value;\n\n          if (i !== 0) {\n            style[MARGIN_TYPE[direction][0]] = this.value / 2 + 'px';\n          } else {\n            style[MARGIN_TYPE[direction][0]] = '';\n          }\n\n          if (i !== slides.length - 1) {\n            style[MARGIN_TYPE[direction][1]] = this.value / 2 + 'px';\n          } else {\n            style[MARGIN_TYPE[direction][1]] = '';\n          }\n        }\n      },\n\n\n      /**\n       * Removes gaps from the slides.\n       *\n       * @param {HTMLCollection} slides\n       * @returns {Void}\n      */\n      remove: function remove(slides) {\n        for (var i = 0, len = slides.length; i < len; i++) {\n          var style = slides[i].style;\n\n          style.marginLeft = '';\n          style.marginRight = '';\n        }\n      }\n    };\n\n    define(Gaps, 'value', {\n      /**\n       * Gets value of the gap.\n       *\n       * @returns {Number}\n       */\n      get: function get() {\n        return toInt(Glide.settings.gap);\n      }\n    });\n\n    define(Gaps, 'grow', {\n      /**\n       * Gets additional dimentions value caused by gaps.\n       * Used to increase width of the slides wrapper.\n       *\n       * @returns {Number}\n       */\n      get: function get() {\n        return Gaps.value * (Components.Sizes.length - 1);\n      }\n    });\n\n    define(Gaps, 'reductor', {\n      /**\n       * Gets reduction value caused by gaps.\n       * Used to subtract width of the slides.\n       *\n       * @returns {Number}\n       */\n      get: function get() {\n        var perView = Glide.settings.perView;\n\n        return Gaps.value * (perView - 1) / perView;\n      }\n    });\n\n    /**\n     * Apply calculated gaps:\n     * - after building, so slides (including clones) will receive proper margins\n     * - on updating via API, to recalculate gaps with new options\n     */\n    Events.on(['build.after', 'update'], throttle(function () {\n      Gaps.apply(Components.Html.wrapper.children);\n    }, 30));\n\n    /**\n     * Remove gaps:\n     * - on destroying to bring markup to its inital state\n     */\n    Events.on('destroy', function () {\n      Gaps.remove(Components.Html.wrapper.children);\n    });\n\n    return Gaps;\n  }\n\n  /**\n   * Finds siblings nodes of the passed node.\n   *\n   * @param  {Element} node\n   * @return {Array}\n   */\n  function siblings(node) {\n    if (node && node.parentNode) {\n      var n = node.parentNode.firstChild;\n      var matched = [];\n\n      for (; n; n = n.nextSibling) {\n        if (n.nodeType === 1 && n !== node) {\n          matched.push(n);\n        }\n      }\n\n      return matched;\n    }\n\n    return [];\n  }\n\n  /**\n   * Checks if passed node exist and is a valid element.\n   *\n   * @param  {Element} node\n   * @return {Boolean}\n   */\n  function exist(node) {\n    if (node && node instanceof window.HTMLElement) {\n      return true;\n    }\n\n    return false;\n  }\n\n  var TRACK_SELECTOR = '[data-glide-el=\"track\"]';\n\n  function Html (Glide, Components) {\n    var Html = {\n      /**\n       * Setup slider HTML nodes.\n       *\n       * @param {Glide} glide\n       */\n      mount: function mount() {\n        this.root = Glide.selector;\n        this.track = this.root.querySelector(TRACK_SELECTOR);\n        this.slides = Array.prototype.slice.call(this.wrapper.children).filter(function (slide) {\n          return !slide.classList.contains(Glide.settings.classes.cloneSlide);\n        });\n      }\n    };\n\n    define(Html, 'root', {\n      /**\n       * Gets node of the glide main element.\n       *\n       * @return {Object}\n       */\n      get: function get() {\n        return Html._r;\n      },\n\n\n      /**\n       * Sets node of the glide main element.\n       *\n       * @return {Object}\n       */\n      set: function set(r) {\n        if (isString(r)) {\n          r = document.querySelector(r);\n        }\n\n        if (exist(r)) {\n          Html._r = r;\n        } else {\n          warn('Root element must be a existing Html node');\n        }\n      }\n    });\n\n    define(Html, 'track', {\n      /**\n       * Gets node of the glide track with slides.\n       *\n       * @return {Object}\n       */\n      get: function get() {\n        return Html._t;\n      },\n\n\n      /**\n       * Sets node of the glide track with slides.\n       *\n       * @return {Object}\n       */\n      set: function set(t) {\n        if (exist(t)) {\n          Html._t = t;\n        } else {\n          warn('Could not find track element. Please use ' + TRACK_SELECTOR + ' attribute.');\n        }\n      }\n    });\n\n    define(Html, 'wrapper', {\n      /**\n       * Gets node of the slides wrapper.\n       *\n       * @return {Object}\n       */\n      get: function get() {\n        return Html.track.children[0];\n      }\n    });\n\n    return Html;\n  }\n\n  function Peek (Glide, Components, Events) {\n    var Peek = {\n      /**\n       * Setups how much to peek based on settings.\n       *\n       * @return {Void}\n       */\n      mount: function mount() {\n        this.value = Glide.settings.peek;\n      }\n    };\n\n    define(Peek, 'value', {\n      /**\n       * Gets value of the peek.\n       *\n       * @returns {Number|Object}\n       */\n      get: function get() {\n        return Peek._v;\n      },\n\n\n      /**\n       * Sets value of the peek.\n       *\n       * @param {Number|Object} value\n       * @return {Void}\n       */\n      set: function set(value) {\n        if (isObject(value)) {\n          value.before = toInt(value.before);\n          value.after = toInt(value.after);\n        } else {\n          value = toInt(value);\n        }\n\n        Peek._v = value;\n      }\n    });\n\n    define(Peek, 'reductor', {\n      /**\n       * Gets reduction value caused by peek.\n       *\n       * @returns {Number}\n       */\n      get: function get() {\n        var value = Peek.value;\n        var perView = Glide.settings.perView;\n\n        if (isObject(value)) {\n          return value.before / perView + value.after / perView;\n        }\n\n        return value * 2 / perView;\n      }\n    });\n\n    /**\n     * Recalculate peeking sizes on:\n     * - when resizing window to update to proper percents\n     */\n    Events.on(['resize', 'update'], function () {\n      Peek.mount();\n    });\n\n    return Peek;\n  }\n\n  function Move (Glide, Components, Events) {\n    var Move = {\n      /**\n       * Constructs move component.\n       *\n       * @returns {Void}\n       */\n      mount: function mount() {\n        this._o = 0;\n      },\n\n\n      /**\n       * Calculates a movement value based on passed offset and currently active index.\n       *\n       * @param  {Number} offset\n       * @return {Void}\n       */\n      make: function make() {\n        var _this = this;\n\n        var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n        this.offset = offset;\n\n        Events.emit('move', {\n          movement: this.value\n        });\n\n        Components.Transition.after(function () {\n          Events.emit('move.after', {\n            movement: _this.value\n          });\n        });\n      }\n    };\n\n    define(Move, 'offset', {\n      /**\n       * Gets an offset value used to modify current translate.\n       *\n       * @return {Object}\n       */\n      get: function get() {\n        return Move._o;\n      },\n\n\n      /**\n       * Sets an offset value used to modify current translate.\n       *\n       * @return {Object}\n       */\n      set: function set(value) {\n        Move._o = !isUndefined(value) ? toInt(value) : 0;\n      }\n    });\n\n    define(Move, 'translate', {\n      /**\n       * Gets a raw movement value.\n       *\n       * @return {Number}\n       */\n      get: function get() {\n        return Components.Sizes.slideWidth * Glide.index;\n      }\n    });\n\n    define(Move, 'value', {\n      /**\n       * Gets an actual movement value corrected by offset.\n       *\n       * @return {Number}\n       */\n      get: function get() {\n        var offset = this.offset;\n        var translate = this.translate;\n\n        if (Components.Direction.is('rtl')) {\n          return translate + offset;\n        }\n\n        return translate - offset;\n      }\n    });\n\n    /**\n     * Make movement to proper slide on:\n     * - before build, so glide will start at `startAt` index\n     * - on each standard run to move to newly calculated index\n     */\n    Events.on(['build.before', 'run'], function () {\n      Move.make();\n    });\n\n    return Move;\n  }\n\n  function Sizes (Glide, Components, Events) {\n    var Sizes = {\n      /**\n       * Setups dimentions of slides.\n       *\n       * @return {Void}\n       */\n      setupSlides: function setupSlides() {\n        var width = this.slideWidth + 'px';\n        var slides = Components.Html.slides;\n\n        for (var i = 0; i < slides.length; i++) {\n          slides[i].style.width = width;\n        }\n      },\n\n\n      /**\n       * Setups dimentions of slides wrapper.\n       *\n       * @return {Void}\n       */\n      setupWrapper: function setupWrapper(dimention) {\n        Components.Html.wrapper.style.width = this.wrapperSize + 'px';\n      },\n\n\n      /**\n       * Removes applied styles from HTML elements.\n       *\n       * @returns {Void}\n       */\n      remove: function remove() {\n        var slides = Components.Html.slides;\n\n        for (var i = 0; i < slides.length; i++) {\n          slides[i].style.width = '';\n        }\n\n        Components.Html.wrapper.style.width = '';\n      }\n    };\n\n    define(Sizes, 'length', {\n      /**\n       * Gets count number of the slides.\n       *\n       * @return {Number}\n       */\n      get: function get() {\n        return Components.Html.slides.length;\n      }\n    });\n\n    define(Sizes, 'width', {\n      /**\n       * Gets width value of the glide.\n       *\n       * @return {Number}\n       */\n      get: function get() {\n        return Components.Html.root.offsetWidth;\n      }\n    });\n\n    define(Sizes, 'wrapperSize', {\n      /**\n       * Gets size of the slides wrapper.\n       *\n       * @return {Number}\n       */\n      get: function get() {\n        return Sizes.slideWidth * Sizes.length + Components.Gaps.grow + Components.Clones.grow;\n      }\n    });\n\n    define(Sizes, 'slideWidth', {\n      /**\n       * Gets width value of the single slide.\n       *\n       * @return {Number}\n       */\n      get: function get() {\n        return Sizes.width / Glide.settings.perView - Components.Peek.reductor - Components.Gaps.reductor;\n      }\n    });\n\n    /**\n     * Apply calculated glide's dimensions:\n     * - before building, so other dimentions (e.g. translate) will be calculated propertly\n     * - when resizing window to recalculate sildes dimensions\n     * - on updating via API, to calculate dimensions based on new options\n     */\n    Events.on(['build.before', 'resize', 'update'], function () {\n      Sizes.setupSlides();\n      Sizes.setupWrapper();\n    });\n\n    /**\n     * Remove calculated glide's dimensions:\n     * - on destoting to bring markup to its inital state\n     */\n    Events.on('destroy', function () {\n      Sizes.remove();\n    });\n\n    return Sizes;\n  }\n\n  function Build (Glide, Components, Events) {\n    var Build = {\n      /**\n       * Init glide building. Adds classes, sets\n       * dimensions and setups initial state.\n       *\n       * @return {Void}\n       */\n      mount: function mount() {\n        Events.emit('build.before');\n\n        this.typeClass();\n        this.activeClass();\n\n        Events.emit('build.after');\n      },\n\n\n      /**\n       * Adds `type` class to the glide element.\n       *\n       * @return {Void}\n       */\n      typeClass: function typeClass() {\n        Components.Html.root.classList.add(Glide.settings.classes[Glide.settings.type]);\n      },\n\n\n      /**\n       * Sets active class to current slide.\n       *\n       * @return {Void}\n       */\n      activeClass: function activeClass() {\n        var classes = Glide.settings.classes;\n        var slide = Components.Html.slides[Glide.index];\n\n        if (slide) {\n          slide.classList.add(classes.activeSlide);\n\n          siblings(slide).forEach(function (sibling) {\n            sibling.classList.remove(classes.activeSlide);\n          });\n        }\n      },\n\n\n      /**\n       * Removes HTML classes applied at building.\n       *\n       * @return {Void}\n       */\n      removeClasses: function removeClasses() {\n        var classes = Glide.settings.classes;\n\n        Components.Html.root.classList.remove(classes[Glide.settings.type]);\n\n        Components.Html.slides.forEach(function (sibling) {\n          sibling.classList.remove(classes.activeSlide);\n        });\n      }\n    };\n\n    /**\n     * Clear building classes:\n     * - on destroying to bring HTML to its initial state\n     * - on updating to remove classes before remounting component\n     */\n    Events.on(['destroy', 'update'], function () {\n      Build.removeClasses();\n    });\n\n    /**\n     * Remount component:\n     * - on resizing of the window to calculate new dimentions\n     * - on updating settings via API\n     */\n    Events.on(['resize', 'update'], function () {\n      Build.mount();\n    });\n\n    /**\n     * Swap active class of current slide:\n     * - after each move to the new index\n     */\n    Events.on('move.after', function () {\n      Build.activeClass();\n    });\n\n    return Build;\n  }\n\n  function Clones (Glide, Components, Events) {\n    var Clones = {\n      /**\n       * Create pattern map and collect slides to be cloned.\n       */\n      mount: function mount() {\n        this.items = [];\n\n        if (Glide.isType('carousel')) {\n          this.items = this.collect();\n        }\n      },\n\n\n      /**\n       * Collect clones with pattern.\n       *\n       * @return {Void}\n       */\n      collect: function collect() {\n        var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n        var slides = Components.Html.slides;\n        var _Glide$settings = Glide.settings,\n            perView = _Glide$settings.perView,\n            classes = _Glide$settings.classes;\n\n\n        var peekIncrementer = +!!Glide.settings.peek;\n        var part = perView + peekIncrementer;\n        var start = slides.slice(0, part);\n        var end = slides.slice(-part);\n\n        for (var r = 0; r < Math.max(1, Math.floor(perView / slides.length)); r++) {\n          for (var i = 0; i < start.length; i++) {\n            var clone = start[i].cloneNode(true);\n\n            clone.classList.add(classes.cloneSlide);\n\n            items.push(clone);\n          }\n\n          for (var _i = 0; _i < end.length; _i++) {\n            var _clone = end[_i].cloneNode(true);\n\n            _clone.classList.add(classes.cloneSlide);\n\n            items.unshift(_clone);\n          }\n        }\n\n        return items;\n      },\n\n\n      /**\n       * Append cloned slides with generated pattern.\n       *\n       * @return {Void}\n       */\n      append: function append() {\n        var items = this.items;\n        var _Components$Html = Components.Html,\n            wrapper = _Components$Html.wrapper,\n            slides = _Components$Html.slides;\n\n\n        var half = Math.floor(items.length / 2);\n        var prepend = items.slice(0, half).reverse();\n        var append = items.slice(half, items.length);\n        var width = Components.Sizes.slideWidth + 'px';\n\n        for (var i = 0; i < append.length; i++) {\n          wrapper.appendChild(append[i]);\n        }\n\n        for (var _i2 = 0; _i2 < prepend.length; _i2++) {\n          wrapper.insertBefore(prepend[_i2], slides[0]);\n        }\n\n        for (var _i3 = 0; _i3 < items.length; _i3++) {\n          items[_i3].style.width = width;\n        }\n      },\n\n\n      /**\n       * Remove all cloned slides.\n       *\n       * @return {Void}\n       */\n      remove: function remove() {\n        var items = this.items;\n\n\n        for (var i = 0; i < items.length; i++) {\n          Components.Html.wrapper.removeChild(items[i]);\n        }\n      }\n    };\n\n    define(Clones, 'grow', {\n      /**\n       * Gets additional dimentions value caused by clones.\n       *\n       * @return {Number}\n       */\n      get: function get() {\n        return (Components.Sizes.slideWidth + Components.Gaps.value) * Clones.items.length;\n      }\n    });\n\n    /**\n     * Append additional slide's clones:\n     * - while glide's type is `carousel`\n     */\n    Events.on('update', function () {\n      Clones.remove();\n      Clones.mount();\n      Clones.append();\n    });\n\n    /**\n     * Append additional slide's clones:\n     * - while glide's type is `carousel`\n     */\n    Events.on('build.before', function () {\n      if (Glide.isType('carousel')) {\n        Clones.append();\n      }\n    });\n\n    /**\n     * Remove clones HTMLElements:\n     * - on destroying, to bring HTML to its initial state\n     */\n    Events.on('destroy', function () {\n      Clones.remove();\n    });\n\n    return Clones;\n  }\n\n  var EventsBinder = function () {\n    /**\n     * Construct a EventsBinder instance.\n     */\n    function EventsBinder() {\n      var listeners = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      classCallCheck(this, EventsBinder);\n\n      this.listeners = listeners;\n    }\n\n    /**\n     * Adds events listeners to arrows HTML elements.\n     *\n     * @param  {String|Array} events\n     * @param  {Element|Window|Document} el\n     * @param  {Function} closure\n     * @param  {Boolean|Object} capture\n     * @return {Void}\n     */\n\n\n    createClass(EventsBinder, [{\n      key: 'on',\n      value: function on(events, el, closure) {\n        var capture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n        if (isString(events)) {\n          events = [events];\n        }\n\n        for (var i = 0; i < events.length; i++) {\n          this.listeners[events[i]] = closure;\n\n          el.addEventListener(events[i], this.listeners[events[i]], capture);\n        }\n      }\n\n      /**\n       * Removes event listeners from arrows HTML elements.\n       *\n       * @param  {String|Array} events\n       * @param  {Element|Window|Document} el\n       * @param  {Boolean|Object} capture\n       * @return {Void}\n       */\n\n    }, {\n      key: 'off',\n      value: function off(events, el) {\n        var capture = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n        if (isString(events)) {\n          events = [events];\n        }\n\n        for (var i = 0; i < events.length; i++) {\n          el.removeEventListener(events[i], this.listeners[events[i]], capture);\n        }\n      }\n\n      /**\n       * Destroy collected listeners.\n       *\n       * @returns {Void}\n       */\n\n    }, {\n      key: 'destroy',\n      value: function destroy() {\n        delete this.listeners;\n      }\n    }]);\n    return EventsBinder;\n  }();\n\n  function Resize (Glide, Components, Events) {\n    /**\n     * Instance of the binder for DOM Events.\n     *\n     * @type {EventsBinder}\n     */\n    var Binder = new EventsBinder();\n\n    var Resize = {\n      /**\n       * Initializes window bindings.\n       */\n      mount: function mount() {\n        this.bind();\n      },\n\n\n      /**\n       * Binds `rezsize` listener to the window.\n       * It's a costly event, so we are debouncing it.\n       *\n       * @return {Void}\n       */\n      bind: function bind() {\n        Binder.on('resize', window, throttle(function () {\n          Events.emit('resize');\n        }, Glide.settings.throttle));\n      },\n\n\n      /**\n       * Unbinds listeners from the window.\n       *\n       * @return {Void}\n       */\n      unbind: function unbind() {\n        Binder.off('resize', window);\n      }\n    };\n\n    /**\n     * Remove bindings from window:\n     * - on destroying, to remove added EventListener\n     */\n    Events.on('destroy', function () {\n      Resize.unbind();\n      Binder.destroy();\n    });\n\n    return Resize;\n  }\n\n  var VALID_DIRECTIONS = ['ltr', 'rtl'];\n  var FLIPED_MOVEMENTS = {\n    '>': '<',\n    '<': '>',\n    '=': '='\n  };\n\n  function Direction (Glide, Components, Events) {\n    var Direction = {\n      /**\n       * Setups gap value based on settings.\n       *\n       * @return {Void}\n       */\n      mount: function mount() {\n        this.value = Glide.settings.direction;\n      },\n\n\n      /**\n       * Resolves pattern based on direction value\n       *\n       * @param {String} pattern\n       * @returns {String}\n       */\n      resolve: function resolve(pattern) {\n        var token = pattern.slice(0, 1);\n\n        if (this.is('rtl')) {\n          return pattern.split(token).join(FLIPED_MOVEMENTS[token]);\n        }\n\n        return pattern;\n      },\n\n\n      /**\n       * Checks value of direction mode.\n       *\n       * @param {String} direction\n       * @returns {Boolean}\n       */\n      is: function is(direction) {\n        return this.value === direction;\n      },\n\n\n      /**\n       * Applies direction class to the root HTML element.\n       *\n       * @return {Void}\n       */\n      addClass: function addClass() {\n        Components.Html.root.classList.add(Glide.settings.classes.direction[this.value]);\n      },\n\n\n      /**\n       * Removes direction class from the root HTML element.\n       *\n       * @return {Void}\n       */\n      removeClass: function removeClass() {\n        Components.Html.root.classList.remove(Glide.settings.classes.direction[this.value]);\n      }\n    };\n\n    define(Direction, 'value', {\n      /**\n       * Gets value of the direction.\n       *\n       * @returns {Number}\n       */\n      get: function get() {\n        return Direction._v;\n      },\n\n\n      /**\n       * Sets value of the direction.\n       *\n       * @param {String} value\n       * @return {Void}\n       */\n      set: function set(value) {\n        if (VALID_DIRECTIONS.indexOf(value) > -1) {\n          Direction._v = value;\n        } else {\n          warn('Direction value must be `ltr` or `rtl`');\n        }\n      }\n    });\n\n    /**\n     * Clear direction class:\n     * - on destroy to bring HTML to its initial state\n     * - on update to remove class before reappling bellow\n     */\n    Events.on(['destroy', 'update'], function () {\n      Direction.removeClass();\n    });\n\n    /**\n     * Remount component:\n     * - on update to reflect changes in direction value\n     */\n    Events.on('update', function () {\n      Direction.mount();\n    });\n\n    /**\n     * Apply direction class:\n     * - before building to apply class for the first time\n     * - on updating to reapply direction class that may changed\n     */\n    Events.on(['build.before', 'update'], function () {\n      Direction.addClass();\n    });\n\n    return Direction;\n  }\n\n  /**\n   * Reflects value of glide movement.\n   *\n   * @param  {Object} Glide\n   * @param  {Object} Components\n   * @return {Object}\n   */\n  function Rtl (Glide, Components) {\n    return {\n      /**\n       * Negates the passed translate if glide is in RTL option.\n       *\n       * @param  {Number} translate\n       * @return {Number}\n       */\n      modify: function modify(translate) {\n        if (Components.Direction.is('rtl')) {\n          return -translate;\n        }\n\n        return translate;\n      }\n    };\n  }\n\n  /**\n   * Updates glide movement with a `gap` settings.\n   *\n   * @param  {Object} Glide\n   * @param  {Object} Components\n   * @return {Object}\n   */\n  function Gap (Glide, Components) {\n    return {\n      /**\n       * Modifies passed translate value with number in the `gap` settings.\n       *\n       * @param  {Number} translate\n       * @return {Number}\n       */\n      modify: function modify(translate) {\n        return translate + Components.Gaps.value * Glide.index;\n      }\n    };\n  }\n\n  /**\n   * Updates glide movement with width of additional clones width.\n   *\n   * @param  {Object} Glide\n   * @param  {Object} Components\n   * @return {Object}\n   */\n  function Grow (Glide, Components) {\n    return {\n      /**\n       * Adds to the passed translate width of the half of clones.\n       *\n       * @param  {Number} translate\n       * @return {Number}\n       */\n      modify: function modify(translate) {\n        return translate + Components.Clones.grow / 2;\n      }\n    };\n  }\n\n  /**\n   * Updates glide movement with a `peek` settings.\n   *\n   * @param  {Object} Glide\n   * @param  {Object} Components\n   * @return {Object}\n   */\n  function Peeking (Glide, Components) {\n    return {\n      /**\n       * Modifies passed translate value with a `peek` setting.\n       *\n       * @param  {Number} translate\n       * @return {Number}\n       */\n      modify: function modify(translate) {\n        if (Glide.settings.focusAt >= 0) {\n          var peek = Components.Peek.value;\n\n          if (isObject(peek)) {\n            return translate - peek.before;\n          }\n\n          return translate - peek;\n        }\n\n        return translate;\n      }\n    };\n  }\n\n  /**\n   * Updates glide movement with a `focusAt` settings.\n   *\n   * @param  {Object} Glide\n   * @param  {Object} Components\n   * @return {Object}\n   */\n  function Focusing (Glide, Components) {\n    return {\n      /**\n       * Modifies passed translate value with index in the `focusAt` setting.\n       *\n       * @param  {Number} translate\n       * @return {Number}\n       */\n      modify: function modify(translate) {\n        var gap = Components.Gaps.value;\n        var width = Components.Sizes.width;\n        var focusAt = Glide.settings.focusAt;\n        var slideWidth = Components.Sizes.slideWidth;\n\n        if (focusAt === 'center') {\n          return translate - (width / 2 - slideWidth / 2);\n        }\n\n        return translate - slideWidth * focusAt - gap * focusAt;\n      }\n    };\n  }\n\n  /**\n   * Applies diffrent transformers on translate value.\n   *\n   * @param  {Object} Glide\n   * @param  {Object} Components\n   * @return {Object}\n   */\n  function mutator (Glide, Components, Events) {\n    /**\n     * Merge instance transformers with collection of default transformers.\n     * It's important that the Rtl component be last on the list,\n     * so it reflects all previous transformations.\n     *\n     * @type {Array}\n     */\n    var TRANSFORMERS = [Gap, Grow, Peeking, Focusing].concat(Glide._t, [Rtl]);\n\n    return {\n      /**\n       * Piplines translate value with registered transformers.\n       *\n       * @param  {Number} translate\n       * @return {Number}\n       */\n      mutate: function mutate(translate) {\n        for (var i = 0; i < TRANSFORMERS.length; i++) {\n          var transformer = TRANSFORMERS[i];\n\n          if (isFunction(transformer) && isFunction(transformer().modify)) {\n            translate = transformer(Glide, Components, Events).modify(translate);\n          } else {\n            warn('Transformer should be a function that returns an object with `modify()` method');\n          }\n        }\n\n        return translate;\n      }\n    };\n  }\n\n  function Translate (Glide, Components, Events) {\n    var Translate = {\n      /**\n       * Sets value of translate on HTML element.\n       *\n       * @param {Number} value\n       * @return {Void}\n       */\n      set: function set(value) {\n        var transform = mutator(Glide, Components).mutate(value);\n\n        Components.Html.wrapper.style.transform = 'translate3d(' + -1 * transform + 'px, 0px, 0px)';\n      },\n\n\n      /**\n       * Removes value of translate from HTML element.\n       *\n       * @return {Void}\n       */\n      remove: function remove() {\n        Components.Html.wrapper.style.transform = '';\n      }\n    };\n\n    /**\n     * Set new translate value:\n     * - on move to reflect index change\n     * - on updating via API to reflect possible changes in options\n     */\n    Events.on('move', function (context) {\n      var gap = Components.Gaps.value;\n      var length = Components.Sizes.length;\n      var width = Components.Sizes.slideWidth;\n\n      if (Glide.isType('carousel') && Components.Run.isOffset('<')) {\n        Components.Transition.after(function () {\n          Events.emit('translate.jump');\n\n          Translate.set(width * (length - 1));\n        });\n\n        return Translate.set(-width - gap * length);\n      }\n\n      if (Glide.isType('carousel') && Components.Run.isOffset('>')) {\n        Components.Transition.after(function () {\n          Events.emit('translate.jump');\n\n          Translate.set(0);\n        });\n\n        return Translate.set(width * length + gap * length);\n      }\n\n      return Translate.set(context.movement);\n    });\n\n    /**\n     * Remove translate:\n     * - on destroying to bring markup to its inital state\n     */\n    Events.on('destroy', function () {\n      Translate.remove();\n    });\n\n    return Translate;\n  }\n\n  function Transition (Glide, Components, Events) {\n    /**\n     * Holds inactivity status of transition.\n     * When true transition is not applied.\n     *\n     * @type {Boolean}\n     */\n    var disabled = false;\n\n    var Transition = {\n      /**\n       * Composes string of the CSS transition.\n       *\n       * @param {String} property\n       * @return {String}\n       */\n      compose: function compose(property) {\n        var settings = Glide.settings;\n\n        if (!disabled) {\n          return property + ' ' + this.duration + 'ms ' + settings.animationTimingFunc;\n        }\n\n        return property + ' 0ms ' + settings.animationTimingFunc;\n      },\n\n\n      /**\n       * Sets value of transition on HTML element.\n       *\n       * @param {String=} property\n       * @return {Void}\n       */\n      set: function set() {\n        var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'transform';\n\n        Components.Html.wrapper.style.transition = this.compose(property);\n      },\n\n\n      /**\n       * Removes value of transition from HTML element.\n       *\n       * @return {Void}\n       */\n      remove: function remove() {\n        Components.Html.wrapper.style.transition = '';\n      },\n\n\n      /**\n       * Runs callback after animation.\n       *\n       * @param  {Function} callback\n       * @return {Void}\n       */\n      after: function after(callback) {\n        setTimeout(function () {\n          callback();\n        }, this.duration);\n      },\n\n\n      /**\n       * Enable transition.\n       *\n       * @return {Void}\n       */\n      enable: function enable() {\n        disabled = false;\n\n        this.set();\n      },\n\n\n      /**\n       * Disable transition.\n       *\n       * @return {Void}\n       */\n      disable: function disable() {\n        disabled = true;\n\n        this.set();\n      }\n    };\n\n    define(Transition, 'duration', {\n      /**\n       * Gets duration of the transition based\n       * on currently running animation type.\n       *\n       * @return {Number}\n       */\n      get: function get() {\n        var settings = Glide.settings;\n\n        if (Glide.isType('slider') && Components.Run.offset) {\n          return settings.rewindDuration;\n        }\n\n        return settings.animationDuration;\n      }\n    });\n\n    /**\n     * Set transition `style` value:\n     * - on each moving, because it may be cleared by offset move\n     */\n    Events.on('move', function () {\n      Transition.set();\n    });\n\n    /**\n     * Disable transition:\n     * - before initial build to avoid transitioning from `0` to `startAt` index\n     * - while resizing window and recalculating dimentions\n     * - on jumping from offset transition at start and end edges in `carousel` type\n     */\n    Events.on(['build.before', 'resize', 'translate.jump'], function () {\n      Transition.disable();\n    });\n\n    /**\n     * Enable transition:\n     * - on each running, because it may be disabled by offset move\n     */\n    Events.on('run', function () {\n      Transition.enable();\n    });\n\n    /**\n     * Remove transition:\n     * - on destroying to bring markup to its inital state\n     */\n    Events.on('destroy', function () {\n      Transition.remove();\n    });\n\n    return Transition;\n  }\n\n  /**\n   * Test via a getter in the options object to see\n   * if the passive property is accessed.\n   *\n   * @see https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection\n   */\n\n  var supportsPassive = false;\n\n  try {\n    var opts = Object.defineProperty({}, 'passive', {\n      get: function get() {\n        supportsPassive = true;\n      }\n    });\n\n    window.addEventListener('testPassive', null, opts);\n    window.removeEventListener('testPassive', null, opts);\n  } catch (e) {}\n\n  var supportsPassive$1 = supportsPassive;\n\n  var START_EVENTS = ['touchstart', 'mousedown'];\n  var MOVE_EVENTS = ['touchmove', 'mousemove'];\n  var END_EVENTS = ['touchend', 'touchcancel', 'mouseup', 'mouseleave'];\n  var MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup', 'mouseleave'];\n\n  function Swipe (Glide, Components, Events) {\n    /**\n     * Instance of the binder for DOM Events.\n     *\n     * @type {EventsBinder}\n     */\n    var Binder = new EventsBinder();\n\n    var swipeSin = 0;\n    var swipeStartX = 0;\n    var swipeStartY = 0;\n    var disabled = false;\n    var capture = supportsPassive$1 ? { passive: true } : false;\n\n    var Swipe = {\n      /**\n       * Initializes swipe bindings.\n       *\n       * @return {Void}\n       */\n      mount: function mount() {\n        this.bindSwipeStart();\n      },\n\n\n      /**\n       * Handler for `swipestart` event. Calculates entry points of the user's tap.\n       *\n       * @param {Object} event\n       * @return {Void}\n       */\n      start: function start(event) {\n        if (!disabled && !Glide.disabled) {\n          this.disable();\n\n          var swipe = this.touches(event);\n\n          swipeSin = null;\n          swipeStartX = toInt(swipe.pageX);\n          swipeStartY = toInt(swipe.pageY);\n\n          this.bindSwipeMove();\n          this.bindSwipeEnd();\n\n          Events.emit('swipe.start');\n        }\n      },\n\n\n      /**\n       * Handler for `swipemove` event. Calculates user's tap angle and distance.\n       *\n       * @param {Object} event\n       */\n      move: function move(event) {\n        if (!Glide.disabled) {\n          var _Glide$settings = Glide.settings,\n              touchAngle = _Glide$settings.touchAngle,\n              touchRatio = _Glide$settings.touchRatio,\n              classes = _Glide$settings.classes;\n\n\n          var swipe = this.touches(event);\n\n          var subExSx = toInt(swipe.pageX) - swipeStartX;\n          var subEySy = toInt(swipe.pageY) - swipeStartY;\n          var powEX = Math.abs(subExSx << 2);\n          var powEY = Math.abs(subEySy << 2);\n          var swipeHypotenuse = Math.sqrt(powEX + powEY);\n          var swipeCathetus = Math.sqrt(powEY);\n\n          swipeSin = Math.asin(swipeCathetus / swipeHypotenuse);\n\n          if (swipeSin * 180 / Math.PI < touchAngle) {\n            event.stopPropagation();\n\n            Components.Move.make(subExSx * toFloat(touchRatio));\n\n            Components.Html.root.classList.add(classes.dragging);\n\n            Events.emit('swipe.move');\n          } else {\n            return false;\n          }\n        }\n      },\n\n\n      /**\n       * Handler for `swipeend` event. Finitializes user's tap and decides about glide move.\n       *\n       * @param {Object} event\n       * @return {Void}\n       */\n      end: function end(event) {\n        if (!Glide.disabled) {\n          var settings = Glide.settings;\n\n          var swipe = this.touches(event);\n          var threshold = this.threshold(event);\n\n          var swipeDistance = swipe.pageX - swipeStartX;\n          var swipeDeg = swipeSin * 180 / Math.PI;\n          var steps = Math.round(swipeDistance / Components.Sizes.slideWidth);\n\n          this.enable();\n\n          if (swipeDistance > threshold && swipeDeg < settings.touchAngle) {\n            // While swipe is positive and greater than threshold move backward.\n            if (settings.perTouch) {\n              steps = Math.min(steps, toInt(settings.perTouch));\n            }\n\n            if (Components.Direction.is('rtl')) {\n              steps = -steps;\n            }\n\n            Components.Run.make(Components.Direction.resolve('<' + steps));\n          } else if (swipeDistance < -threshold && swipeDeg < settings.touchAngle) {\n            // While swipe is negative and lower than negative threshold move forward.\n            if (settings.perTouch) {\n              steps = Math.max(steps, -toInt(settings.perTouch));\n            }\n\n            if (Components.Direction.is('rtl')) {\n              steps = -steps;\n            }\n\n            Components.Run.make(Components.Direction.resolve('>' + steps));\n          } else {\n            // While swipe don't reach distance apply previous transform.\n            Components.Move.make();\n          }\n\n          Components.Html.root.classList.remove(settings.classes.dragging);\n\n          this.unbindSwipeMove();\n          this.unbindSwipeEnd();\n\n          Events.emit('swipe.end');\n        }\n      },\n\n\n      /**\n       * Binds swipe's starting event.\n       *\n       * @return {Void}\n       */\n      bindSwipeStart: function bindSwipeStart() {\n        var _this = this;\n\n        var settings = Glide.settings;\n\n        if (settings.swipeThreshold) {\n          Binder.on(START_EVENTS[0], Components.Html.wrapper, function (event) {\n            _this.start(event);\n          }, capture);\n        }\n\n        if (settings.dragThreshold) {\n          Binder.on(START_EVENTS[1], Components.Html.wrapper, function (event) {\n            _this.start(event);\n          }, capture);\n        }\n      },\n\n\n      /**\n       * Unbinds swipe's starting event.\n       *\n       * @return {Void}\n       */\n      unbindSwipeStart: function unbindSwipeStart() {\n        Binder.off(START_EVENTS[0], Components.Html.wrapper, capture);\n        Binder.off(START_EVENTS[1], Components.Html.wrapper, capture);\n      },\n\n\n      /**\n       * Binds swipe's moving event.\n       *\n       * @return {Void}\n       */\n      bindSwipeMove: function bindSwipeMove() {\n        var _this2 = this;\n\n        Binder.on(MOVE_EVENTS, Components.Html.wrapper, throttle(function (event) {\n          _this2.move(event);\n        }, Glide.settings.throttle), capture);\n      },\n\n\n      /**\n       * Unbinds swipe's moving event.\n       *\n       * @return {Void}\n       */\n      unbindSwipeMove: function unbindSwipeMove() {\n        Binder.off(MOVE_EVENTS, Components.Html.wrapper, capture);\n      },\n\n\n      /**\n       * Binds swipe's ending event.\n       *\n       * @return {Void}\n       */\n      bindSwipeEnd: function bindSwipeEnd() {\n        var _this3 = this;\n\n        Binder.on(END_EVENTS, Components.Html.wrapper, function (event) {\n          _this3.end(event);\n        });\n      },\n\n\n      /**\n       * Unbinds swipe's ending event.\n       *\n       * @return {Void}\n       */\n      unbindSwipeEnd: function unbindSwipeEnd() {\n        Binder.off(END_EVENTS, Components.Html.wrapper);\n      },\n\n\n      /**\n       * Normalizes event touches points accorting to different types.\n       *\n       * @param {Object} event\n       */\n      touches: function touches(event) {\n        if (MOUSE_EVENTS.indexOf(event.type) > -1) {\n          return event;\n        }\n\n        return event.touches[0] || event.changedTouches[0];\n      },\n\n\n      /**\n       * Gets value of minimum swipe distance settings based on event type.\n       *\n       * @return {Number}\n       */\n      threshold: function threshold(event) {\n        var settings = Glide.settings;\n\n        if (MOUSE_EVENTS.indexOf(event.type) > -1) {\n          return settings.dragThreshold;\n        }\n\n        return settings.swipeThreshold;\n      },\n\n\n      /**\n       * Enables swipe event.\n       *\n       * @return {self}\n       */\n      enable: function enable() {\n        disabled = false;\n\n        Components.Transition.enable();\n\n        return this;\n      },\n\n\n      /**\n       * Disables swipe event.\n       *\n       * @return {self}\n       */\n      disable: function disable() {\n        disabled = true;\n\n        Components.Transition.disable();\n\n        return this;\n      }\n    };\n\n    /**\n     * Add component class:\n     * - after initial building\n     */\n    Events.on('build.after', function () {\n      Components.Html.root.classList.add(Glide.settings.classes.swipeable);\n    });\n\n    /**\n     * Remove swiping bindings:\n     * - on destroying, to remove added EventListeners\n     */\n    Events.on('destroy', function () {\n      Swipe.unbindSwipeStart();\n      Swipe.unbindSwipeMove();\n      Swipe.unbindSwipeEnd();\n      Binder.destroy();\n    });\n\n    return Swipe;\n  }\n\n  function Images (Glide, Components, Events) {\n    /**\n     * Instance of the binder for DOM Events.\n     *\n     * @type {EventsBinder}\n     */\n    var Binder = new EventsBinder();\n\n    var Images = {\n      /**\n       * Binds listener to glide wrapper.\n       *\n       * @return {Void}\n       */\n      mount: function mount() {\n        this.bind();\n      },\n\n\n      /**\n       * Binds `dragstart` event on wrapper to prevent dragging images.\n       *\n       * @return {Void}\n       */\n      bind: function bind() {\n        Binder.on('dragstart', Components.Html.wrapper, this.dragstart);\n      },\n\n\n      /**\n       * Unbinds `dragstart` event on wrapper.\n       *\n       * @return {Void}\n       */\n      unbind: function unbind() {\n        Binder.off('dragstart', Components.Html.wrapper);\n      },\n\n\n      /**\n       * Event handler. Prevents dragging.\n       *\n       * @return {Void}\n       */\n      dragstart: function dragstart(event) {\n        event.preventDefault();\n      }\n    };\n\n    /**\n     * Remove bindings from images:\n     * - on destroying, to remove added EventListeners\n     */\n    Events.on('destroy', function () {\n      Images.unbind();\n      Binder.destroy();\n    });\n\n    return Images;\n  }\n\n  function Anchors (Glide, Components, Events) {\n    /**\n     * Instance of the binder for DOM Events.\n     *\n     * @type {EventsBinder}\n     */\n    var Binder = new EventsBinder();\n\n    /**\n     * Holds detaching status of anchors.\n     * Prevents detaching of already detached anchors.\n     *\n     * @private\n     * @type {Boolean}\n     */\n    var detached = false;\n\n    /**\n     * Holds preventing status of anchors.\n     * If `true` redirection after click will be disabled.\n     *\n     * @private\n     * @type {Boolean}\n     */\n    var prevented = false;\n\n    var Anchors = {\n      /**\n       * Setups a initial state of anchors component.\n       *\n       * @returns {Void}\n       */\n      mount: function mount() {\n        /**\n         * Holds collection of anchors elements.\n         *\n         * @private\n         * @type {HTMLCollection}\n         */\n        this._a = Components.Html.wrapper.querySelectorAll('a');\n\n        this.bind();\n      },\n\n\n      /**\n       * Binds events to anchors inside a track.\n       *\n       * @return {Void}\n       */\n      bind: function bind() {\n        Binder.on('click', Components.Html.wrapper, this.click);\n      },\n\n\n      /**\n       * Unbinds events attached to anchors inside a track.\n       *\n       * @return {Void}\n       */\n      unbind: function unbind() {\n        Binder.off('click', Components.Html.wrapper);\n      },\n\n\n      /**\n       * Handler for click event. Prevents clicks when glide is in `prevent` status.\n       *\n       * @param  {Object} event\n       * @return {Void}\n       */\n      click: function click(event) {\n        if (prevented) {\n          event.stopPropagation();\n          event.preventDefault();\n        }\n      },\n\n\n      /**\n       * Detaches anchors click event inside glide.\n       *\n       * @return {self}\n       */\n      detach: function detach() {\n        prevented = true;\n\n        if (!detached) {\n          for (var i = 0; i < this.items.length; i++) {\n            this.items[i].draggable = false;\n\n            this.items[i].setAttribute('data-href', this.items[i].getAttribute('href'));\n\n            this.items[i].removeAttribute('href');\n          }\n\n          detached = true;\n        }\n\n        return this;\n      },\n\n\n      /**\n       * Attaches anchors click events inside glide.\n       *\n       * @return {self}\n       */\n      attach: function attach() {\n        prevented = false;\n\n        if (detached) {\n          for (var i = 0; i < this.items.length; i++) {\n            this.items[i].draggable = true;\n\n            this.items[i].setAttribute('href', this.items[i].getAttribute('data-href'));\n          }\n\n          detached = false;\n        }\n\n        return this;\n      }\n    };\n\n    define(Anchors, 'items', {\n      /**\n       * Gets collection of the arrows HTML elements.\n       *\n       * @return {HTMLElement[]}\n       */\n      get: function get() {\n        return Anchors._a;\n      }\n    });\n\n    /**\n     * Detach anchors inside slides:\n     * - on swiping, so they won't redirect to its `href` attributes\n     */\n    Events.on('swipe.move', function () {\n      Anchors.detach();\n    });\n\n    /**\n     * Attach anchors inside slides:\n     * - after swiping and transitions ends, so they can redirect after click again\n     */\n    Events.on('swipe.end', function () {\n      Components.Transition.after(function () {\n        Anchors.attach();\n      });\n    });\n\n    /**\n     * Unbind anchors inside slides:\n     * - on destroying, to bring anchors to its initial state\n     */\n    Events.on('destroy', function () {\n      Anchors.attach();\n      Anchors.unbind();\n      Binder.destroy();\n    });\n\n    return Anchors;\n  }\n\n  var NAV_SELECTOR = '[data-glide-el=\"controls[nav]\"]';\n  var CONTROLS_SELECTOR = '[data-glide-el^=\"controls\"]';\n\n  function Controls (Glide, Components, Events) {\n    /**\n     * Instance of the binder for DOM Events.\n     *\n     * @type {EventsBinder}\n     */\n    var Binder = new EventsBinder();\n\n    var capture = supportsPassive$1 ? { passive: true } : false;\n\n    var Controls = {\n      /**\n       * Inits arrows. Binds events listeners\n       * to the arrows HTML elements.\n       *\n       * @return {Void}\n       */\n      mount: function mount() {\n        /**\n         * Collection of navigation HTML elements.\n         *\n         * @private\n         * @type {HTMLCollection}\n         */\n        this._n = Components.Html.root.querySelectorAll(NAV_SELECTOR);\n\n        /**\n         * Collection of controls HTML elements.\n         *\n         * @private\n         * @type {HTMLCollection}\n         */\n        this._c = Components.Html.root.querySelectorAll(CONTROLS_SELECTOR);\n\n        this.addBindings();\n      },\n\n\n      /**\n       * Sets active class to current slide.\n       *\n       * @return {Void}\n       */\n      setActive: function setActive() {\n        for (var i = 0; i < this._n.length; i++) {\n          this.addClass(this._n[i].children);\n        }\n      },\n\n\n      /**\n       * Removes active class to current slide.\n       *\n       * @return {Void}\n       */\n      removeActive: function removeActive() {\n        for (var i = 0; i < this._n.length; i++) {\n          this.removeClass(this._n[i].children);\n        }\n      },\n\n\n      /**\n       * Toggles active class on items inside navigation.\n       *\n       * @param  {HTMLElement} controls\n       * @return {Void}\n       */\n      addClass: function addClass(controls) {\n        var settings = Glide.settings;\n        var item = controls[Glide.index];\n\n        if (item) {\n          item.classList.add(settings.classes.activeNav);\n\n          siblings(item).forEach(function (sibling) {\n            sibling.classList.remove(settings.classes.activeNav);\n          });\n        }\n      },\n\n\n      /**\n       * Removes active class from active control.\n       *\n       * @param  {HTMLElement} controls\n       * @return {Void}\n       */\n      removeClass: function removeClass(controls) {\n        var item = controls[Glide.index];\n\n        if (item) {\n          item.classList.remove(Glide.settings.classes.activeNav);\n        }\n      },\n\n\n      /**\n       * Adds handles to the each group of controls.\n       *\n       * @return {Void}\n       */\n      addBindings: function addBindings() {\n        for (var i = 0; i < this._c.length; i++) {\n          this.bind(this._c[i].children);\n        }\n      },\n\n\n      /**\n       * Removes handles from the each group of controls.\n       *\n       * @return {Void}\n       */\n      removeBindings: function removeBindings() {\n        for (var i = 0; i < this._c.length; i++) {\n          this.unbind(this._c[i].children);\n        }\n      },\n\n\n      /**\n       * Binds events to arrows HTML elements.\n       *\n       * @param {HTMLCollection} elements\n       * @return {Void}\n       */\n      bind: function bind(elements) {\n        for (var i = 0; i < elements.length; i++) {\n          Binder.on('click', elements[i], this.click);\n          Binder.on('touchstart', elements[i], this.click, capture);\n        }\n      },\n\n\n      /**\n       * Unbinds events binded to the arrows HTML elements.\n       *\n       * @param {HTMLCollection} elements\n       * @return {Void}\n       */\n      unbind: function unbind(elements) {\n        for (var i = 0; i < elements.length; i++) {\n          Binder.off(['click', 'touchstart'], elements[i]);\n        }\n      },\n\n\n      /**\n       * Handles `click` event on the arrows HTML elements.\n       * Moves slider in driection precised in\n       * `data-glide-dir` attribute.\n       *\n       * @param {Object} event\n       * @return {Void}\n       */\n      click: function click(event) {\n        event.preventDefault();\n\n        Components.Run.make(Components.Direction.resolve(event.currentTarget.getAttribute('data-glide-dir')));\n      }\n    };\n\n    define(Controls, 'items', {\n      /**\n       * Gets collection of the controls HTML elements.\n       *\n       * @return {HTMLElement[]}\n       */\n      get: function get() {\n        return Controls._c;\n      }\n    });\n\n    /**\n     * Swap active class of current navigation item:\n     * - after mounting to set it to initial index\n     * - after each move to the new index\n     */\n    Events.on(['mount.after', 'move.after'], function () {\n      Controls.setActive();\n    });\n\n    /**\n     * Remove bindings and HTML Classes:\n     * - on destroying, to bring markup to its initial state\n     */\n    Events.on('destroy', function () {\n      Controls.removeBindings();\n      Controls.removeActive();\n      Binder.destroy();\n    });\n\n    return Controls;\n  }\n\n  function Keyboard (Glide, Components, Events) {\n    /**\n     * Instance of the binder for DOM Events.\n     *\n     * @type {EventsBinder}\n     */\n    var Binder = new EventsBinder();\n\n    var Keyboard = {\n      /**\n       * Binds keyboard events on component mount.\n       *\n       * @return {Void}\n       */\n      mount: function mount() {\n        if (Glide.settings.keyboard) {\n          this.bind();\n        }\n      },\n\n\n      /**\n       * Adds keyboard press events.\n       *\n       * @return {Void}\n       */\n      bind: function bind() {\n        Binder.on('keyup', document, this.press);\n      },\n\n\n      /**\n       * Removes keyboard press events.\n       *\n       * @return {Void}\n       */\n      unbind: function unbind() {\n        Binder.off('keyup', document);\n      },\n\n\n      /**\n       * Handles keyboard's arrows press and moving glide foward and backward.\n       *\n       * @param  {Object} event\n       * @return {Void}\n       */\n      press: function press(event) {\n        if (event.keyCode === 39) {\n          Components.Run.make(Components.Direction.resolve('>'));\n        }\n\n        if (event.keyCode === 37) {\n          Components.Run.make(Components.Direction.resolve('<'));\n        }\n      }\n    };\n\n    /**\n     * Remove bindings from keyboard:\n     * - on destroying to remove added events\n     * - on updating to remove events before remounting\n     */\n    Events.on(['destroy', 'update'], function () {\n      Keyboard.unbind();\n    });\n\n    /**\n     * Remount component\n     * - on updating to reflect potential changes in settings\n     */\n    Events.on('update', function () {\n      Keyboard.mount();\n    });\n\n    /**\n     * Destroy binder:\n     * - on destroying to remove listeners\n     */\n    Events.on('destroy', function () {\n      Binder.destroy();\n    });\n\n    return Keyboard;\n  }\n\n  function Autoplay (Glide, Components, Events) {\n    /**\n     * Instance of the binder for DOM Events.\n     *\n     * @type {EventsBinder}\n     */\n    var Binder = new EventsBinder();\n\n    var Autoplay = {\n      /**\n       * Initializes autoplaying and events.\n       *\n       * @return {Void}\n       */\n      mount: function mount() {\n        this.start();\n\n        if (Glide.settings.hoverpause) {\n          this.bind();\n        }\n      },\n\n\n      /**\n       * Starts autoplaying in configured interval.\n       *\n       * @param {Boolean|Number} force Run autoplaying with passed interval regardless of `autoplay` settings\n       * @return {Void}\n       */\n      start: function start() {\n        var _this = this;\n\n        if (Glide.settings.autoplay) {\n          if (isUndefined(this._i)) {\n            this._i = setInterval(function () {\n              _this.stop();\n\n              Components.Run.make('>');\n\n              _this.start();\n            }, this.time);\n          }\n        }\n      },\n\n\n      /**\n       * Stops autorunning of the glide.\n       *\n       * @return {Void}\n       */\n      stop: function stop() {\n        this._i = clearInterval(this._i);\n      },\n\n\n      /**\n       * Stops autoplaying while mouse is over glide's area.\n       *\n       * @return {Void}\n       */\n      bind: function bind() {\n        var _this2 = this;\n\n        Binder.on('mouseover', Components.Html.root, function () {\n          _this2.stop();\n        });\n\n        Binder.on('mouseout', Components.Html.root, function () {\n          _this2.start();\n        });\n      },\n\n\n      /**\n       * Unbind mouseover events.\n       *\n       * @returns {Void}\n       */\n      unbind: function unbind() {\n        Binder.off(['mouseover', 'mouseout'], Components.Html.root);\n      }\n    };\n\n    define(Autoplay, 'time', {\n      /**\n       * Gets time period value for the autoplay interval. Prioritizes\n       * times in `data-glide-autoplay` attrubutes over options.\n       *\n       * @return {Number}\n       */\n      get: function get() {\n        var autoplay = Components.Html.slides[Glide.index].getAttribute('data-glide-autoplay');\n\n        if (autoplay) {\n          return toInt(autoplay);\n        }\n\n        return toInt(Glide.settings.autoplay);\n      }\n    });\n\n    /**\n     * Stop autoplaying and unbind events:\n     * - on destroying, to clear defined interval\n     * - on updating via API to reset interval that may changed\n     */\n    Events.on(['destroy', 'update'], function () {\n      Autoplay.unbind();\n    });\n\n    /**\n     * Stop autoplaying:\n     * - before each run, to restart autoplaying\n     * - on pausing via API\n     * - on destroying, to clear defined interval\n     * - while starting a swipe\n     * - on updating via API to reset interval that may changed\n     */\n    Events.on(['run.before', 'pause', 'destroy', 'swipe.start', 'update'], function () {\n      Autoplay.stop();\n    });\n\n    /**\n     * Start autoplaying:\n     * - after each run, to restart autoplaying\n     * - on playing via API\n     * - while ending a swipe\n     */\n    Events.on(['run.after', 'play', 'swipe.end'], function () {\n      Autoplay.start();\n    });\n\n    /**\n     * Remount autoplaying:\n     * - on updating via API to reset interval that may changed\n     */\n    Events.on('update', function () {\n      Autoplay.mount();\n    });\n\n    /**\n     * Destroy a binder:\n     * - on destroying glide instance to clearup listeners\n     */\n    Events.on('destroy', function () {\n      Binder.destroy();\n    });\n\n    return Autoplay;\n  }\n\n  /**\n   * Sorts keys of breakpoint object so they will be ordered from lower to bigger.\n   *\n   * @param {Object} points\n   * @returns {Object}\n   */\n  function sortBreakpoints(points) {\n    if (isObject(points)) {\n      return sortKeys(points);\n    } else {\n      warn('Breakpoints option must be an object');\n    }\n\n    return {};\n  }\n\n  function Breakpoints (Glide, Components, Events) {\n    /**\n     * Instance of the binder for DOM Events.\n     *\n     * @type {EventsBinder}\n     */\n    var Binder = new EventsBinder();\n\n    /**\n     * Holds reference to settings.\n     *\n     * @type {Object}\n     */\n    var settings = Glide.settings;\n\n    /**\n     * Holds reference to breakpoints object in settings. Sorts breakpoints\n     * from smaller to larger. It is required in order to proper\n     * matching currently active breakpoint settings.\n     *\n     * @type {Object}\n     */\n    var points = sortBreakpoints(settings.breakpoints);\n\n    /**\n     * Cache initial settings before overwritting.\n     *\n     * @type {Object}\n     */\n    var defaults = _extends({}, settings);\n\n    var Breakpoints = {\n      /**\n       * Matches settings for currectly matching media breakpoint.\n       *\n       * @param {Object} points\n       * @returns {Object}\n       */\n      match: function match(points) {\n        if (typeof window.matchMedia !== 'undefined') {\n          for (var point in points) {\n            if (points.hasOwnProperty(point)) {\n              if (window.matchMedia('(max-width: ' + point + 'px)').matches) {\n                return points[point];\n              }\n            }\n          }\n        }\n\n        return defaults;\n      }\n    };\n\n    /**\n     * Overwrite instance settings with currently matching breakpoint settings.\n     * This happens right after component initialization.\n     */\n    _extends(settings, Breakpoints.match(points));\n\n    /**\n     * Update glide with settings of matched brekpoint:\n     * - window resize to update slider\n     */\n    Binder.on('resize', window, throttle(function () {\n      Glide.settings = mergeOptions(settings, Breakpoints.match(points));\n    }, Glide.settings.throttle));\n\n    /**\n     * Resort and update default settings:\n     * - on reinit via API, so breakpoint matching will be performed with options\n     */\n    Events.on('update', function () {\n      points = sortBreakpoints(points);\n\n      defaults = _extends({}, settings);\n    });\n\n    /**\n     * Unbind resize listener:\n     * - on destroying, to bring markup to its initial state\n     */\n    Events.on('destroy', function () {\n      Binder.off('resize', window);\n    });\n\n    return Breakpoints;\n  }\n\n  var COMPONENTS = {\n    // Required\n    Html: Html,\n    Translate: Translate,\n    Transition: Transition,\n    Direction: Direction,\n    Peek: Peek,\n    Sizes: Sizes,\n    Gaps: Gaps,\n    Move: Move,\n    Clones: Clones,\n    Resize: Resize,\n    Build: Build,\n    Run: Run,\n\n    // Optional\n    Swipe: Swipe,\n    Images: Images,\n    Anchors: Anchors,\n    Controls: Controls,\n    Keyboard: Keyboard,\n    Autoplay: Autoplay,\n    Breakpoints: Breakpoints\n  };\n\n  var Glide$1 = function (_Core) {\n    inherits(Glide$$1, _Core);\n\n    function Glide$$1() {\n      classCallCheck(this, Glide$$1);\n      return possibleConstructorReturn(this, (Glide$$1.__proto__ || Object.getPrototypeOf(Glide$$1)).apply(this, arguments));\n    }\n\n    createClass(Glide$$1, [{\n      key: 'mount',\n      value: function mount() {\n        var extensions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        return get(Glide$$1.prototype.__proto__ || Object.getPrototypeOf(Glide$$1.prototype), 'mount', this).call(this, _extends({}, COMPONENTS, extensions));\n      }\n    }]);\n    return Glide$$1;\n  }(Glide);\n\n  return Glide$1;\n\n})));\n","const Glide = require('@glidejs/glide');\n\nfunction setBreakpoints() {\n    if (window.matchMedia('(max-width: 768px)').matches) {\n        new Glide('.glide', {\n            type: 'slider',\n            startAt: 0,\n            perView: 1,\n            gap: 24,\n            bound: false,\n            rewind: false,\n            focusAt: 'center',\n        }).mount()\n    } else {\n        new Glide('.glide', {\n            type: 'slider',\n            startAt: 0,\n            perView: 3.5,\n            gap: 24,\n            bound: false,\n            rewind: false,\n            focusAt: 'center',\n        }).mount()\n    }\n}\n\nsetBreakpoints();\nwindow.addEventListener('resize', setBreakpoints)"]}